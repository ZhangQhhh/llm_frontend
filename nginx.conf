# 定义工作进程数，通常等于CPU核心数
worker_processes auto;

events {
    worker_connections 1024;
}

http {
    # 包含 MIME 类型配置（关键：确保 CSS/JS 文件能被正确识别）
    include /etc/nginx/mime.types;
    default_type application/octet-stream;

    # 定义缓存路径和参数
    proxy_cache_path /var/cache/nginx levels=1:2 keys_zone=my_cache:10m max_size=10g inactive=60m use_temp_path=off;

    geo $maintenance {
        default 1;
        127.0.0.1 0;           # 允许服务器本机

        # --- 把你用于测试的 IP/IP 段加在这里 ---
        # 1.2.3.4 0;           # 示例：你的家庭/公司出口 IP

        # 我从你的配置中提取了你允许的 IP 段
        53.21.18.98 0;
        53.21.18.97 0;
    }



    server {
        listen 80;
        server_name localhost;

        access_log /var/log/nginx/access.log;
        error_log /var/log/nginx/error.log;


       # 2. 如果开关文件存在，设置变量
        set $maint_check "0"; # <-- 确保在这里初始化
        if (-f /usr/share/nginx/html/maintenance.on) {
            set $maint_check "1";
        }

        # 3. 拼接 $maintenance 变量 (0 或 1)
        #    如果文件存在 ($maint_check="1") 且 IP不在白名单 ($maintenance="1")
        #    则 $maint_check 最终会变为 "11"
        set $maint_check "${maint_check}${maintenance}";

        # --- 新增步骤：检查请求的是否是维护页本身 ---
        set $is_maint_page "0";
        if ($request_uri = "/maintenance.html") {
            set $is_maint_page "1";
        }

        # 4. 再次拼接变量
        #    "110" = 维护开启 AND IP不在白名单 AND 请求的不是维护页
        #    "111" = 维护开启 AND IP不在白名单 AND 请求的是维护页 (此时不拦截)
        set $maint_check "${maint_check}${is_maint_page}";

        # 5. 最终检查：只在 "110" 时才返回 503
        if ($maint_check = "110") {
            return 503;
        }

        # --- 步骤 3：定义 503 错误页面 (已修改，解决 405 错误) ---
        # (同样在 server 块的顶层)
        error_page 503 = /maintenance.html;



        location = /maintenance.html {
          root /usr/share/nginx/html;
         }

        # --- Vue 应用的静态资源（CSS/JS/图片等）---
        # 优先级更高，匹配 /static/css/, /static/js/ 等 Vue 打包的资源
        location ~ ^/static/(css|js|img|fonts)/ {
            root /usr/share/nginx/html/dist;
            expires 30d;
            add_header Cache-Control "public, immutable";
        }
        
        # --- 原有的静态文件（如 knowledge_answer_v4.html 使用的字体等）---
        # 兜底规则，处理其他 /static/ 请求
        location /static/ {
            root /usr/share/nginx/html;
            expires 30d;
            add_header Cache-Control "public, immutable";
        }

        location /llm {
            # --- IP 访问控制规则 ---
            allow 10.124.146.0/23;
            allow 53.21.16.0/22;
            deny all;

            # --- 关键：添加 rewrite 规则 ---
            # 这会将 /llm/some/path 重写为 /some/path
            rewrite ^/llm(.*)$ $1 break;

            proxy_pass http://127.0.0.1:5000;
            proxy_set_header Host $host;
            proxy_set_header X-Real-IP $remote_addr;
            proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
            proxy_set_header X-Forwarded-Proto $scheme;
        }

         # 因为 "/api/knowledge_chat" 比 "/api/" 更长，Nginx 会优先匹配这个规则
        location /api/knowledge_chat {
            # 关键：告诉 Nginx 将这个特定请求转发到 5000 端口的服务
            # 注意：这里的 proxy_pass 后面没有 /，这意味着原始请求路径会被完整附加
            # 例如 /api/knowledge_chat -> http://127.0.0.1:5000/api/knowledge_chat
            proxy_pass http://127.0.0.1:5000;

            # 复制标准的代理头信息，确保后端服务能获取到真实的客户端信息
            proxy_set_header Host $host;
            proxy_set_header X-Real-IP $remote_addr;
            proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
            proxy_set_header X-Forwarded-Proto $scheme;
        }

        location /api/ {
            # 关键：将请求转发到运行在 3000 端口的服务
            proxy_pass http://127.0.0.1:3000/api/;

            # 以下是推荐的代理头信息，确保后端服务能获取到真实的客户端信息
            proxy_set_header Host $host;
            proxy_set_header X-Real-IP $remote_addr;
            proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
            proxy_set_header X-Forwarded-Proto $scheme;
        }

        # --- API 代理 (优化后版本) ---
        location /tt/qwen/ {

             # --- IP 访问控制 ---
            # 允许特定的IP访问，可以添加多个 allow
            allow 10.124.146.0/23; #
            allow 53.21.16.0/22;      #
            # 拒绝所有其他IP
            deny all;

            # 预检请求（OPTIONS）的处理
            if ($request_method = 'OPTIONS') {
                add_header 'Access-Control-Allow-Origin' '*' always;
                add_header 'Access-Control-Allow-Methods' 'GET, POST, OPTIONS' always;
                add_header 'Access-Control-Allow-Headers' 'Content-Type, Authorization' always;
                add_header 'Access-Control-Max-Age' 1728000;
                return 204;
            }

            # 使用 rewrite 明确重写 URL 路径
            rewrite ^/tt/qwen/(.*)$ /$1 break;

            # 代理转发到您的通义千问API服务
            proxy_pass http://53.2.102.1:2025;

            # 传递必要的头信息
            proxy_set_header Host $host;
            proxy_set_header X-Real-IP $remote_addr;
            proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
            proxy_set_header X-Forwarded-Proto $scheme;

            # 为正常请求添加 CORS 头
            add_header 'Access-Control-Allow-Origin' '*' always;
        }

        # 针对本地千问api的代理
         location /qwen32/ {
            # --- IP 访问控制 ---
            # 允许特定的IP访问，可以添加多个 allow
            allow 10.124.146.0/23; #
            allow 53.21.16.0/22;      #
            # 拒绝所有其他IP
            deny all;

            # 预检请求（OPTIONS）的处理
            if ($request_method = 'OPTIONS') {
                add_header 'Access-Control-Allow-Origin' '*' always;
                add_header 'Access-Control-Allow-Methods' 'GET, POST, OPTIONS' always;
                add_header 'Access-Control-Allow-Headers' 'Content-Type, Authorization' always;
                add_header 'Access-Control-Max-Age' 1728000;
                return 204;
            }

            # 使用 rewrite 重写 URL 路径
            # 这会将 /qwen32/some/path 重写为 /v1/some/path
            rewrite ^/qwen32/(.*)$ /v1/$1 break;

            # 代理转发到您的 qwen3-32b API 服务
            # 注意：由于 rewrite 已经添加了 /v1 前缀，这里不需要加
            proxy_pass http://127.0.0.1:1025;

            # 传递必要的头信息
            proxy_set_header Host $host;
            proxy_set_header X-Real-IP $remote_addr;
            proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
            proxy_set_header X-Forwarded-Proto $scheme;

            # 为正常请求添加 CORS 头
            add_header 'Access-Control-Allow-Origin' '*' always;
        }


        # --- 根目录和主页面 ---
        location / {
            root /usr/share/nginx/html/dist;
            index index.html index.htm;

            # --- 必须添加这行来支持 Vue Router 的 History 模式 ---
            # 它会尝试查找精确的文件 ($uri)，
            # 然后尝试查找目录 ($uri/)，
            # 如果都找不到（例如 /user/profile），就 fallback 到 /index.html
            try_files $uri $uri/ /index.html;
        }

        # --- AI 聊天页面 ---
        location /ai {
           deny 53.3.1.2;
           allow all;
           root /usr/share/nginx/html;
           try_files /ai.html =404;
        }

	location /supervisory{
	   root /usr/share/nginx/html;
	   try_files /demo.html =404;
	}

        # --- UI 代理 (例如 Gradio/Streamlit) ---
        location /ui/ {
            proxy_pass http://127.0.0.1:7860/;
            proxy_http_version 1.1;
            proxy_set_header Upgrade $http_upgrade;
            proxy_set_header Connection "upgrade";
            proxy_set_header Host $host;
        }

       # --- Qdrant 反向代理最终配置（开始） ---

        # 规则1：主入口，用于浏览器直接访问
        location /qdrant/ {
            # 当用户只访问 /qdrant/ 时，自动跳转到 dashboard
            rewrite ^/qdrant/?$ /qdrant/dashboard/ permanent;

            # 代理转发到 Qdrant 的 Web UI 端口 6333
            proxy_pass http://127.0.0.1:6333/;

            # WebSocket 支持
            proxy_http_version 1.1;
            proxy_set_header Upgrade $http_upgrade;
            proxy_set_header Connection "upgrade";
            proxy_set_header Host $host;
        }

        # 规则2：捕获所有发往根目录的 API 请求
        # 使用正则表达式匹配多个 API 路径
        location ~ ^/(collections|cluster|telemetry|locks) {
            # 同样将它们转发到正确的 Qdrant 端口
            proxy_pass http://127.0.0.1:6333;
        }

        # 规则3：捕获所有发往根目录的 UI 静态资源
        # 比如 logo.svg, assets/ 等
        location /dashboard/ {
            # 同样将它们转发到正确的 Qdrant 端口
            proxy_pass http://127.0.0.1:6333;
        }

        # --- Qdrant 反向代理最终配置（结束） ---

        # --- TensorBoard 代理 ---
        location /zqboard/ {
            proxy_pass http://127.0.0.1:6006/;
            proxy_http_version 1.1;
            proxy_set_header Upgrade $http_upgrade;
            proxy_set_header Connection "upgrade";
            proxy_set_header Host $host;
        }
    }
}